const puppeteer = require('puppeteer');
const path = require('path');
const { spawn } = require('child_process');

async function runTest(testFunction, page, ...args) {
    try {
        await testFunction(page, ...args);
    } catch (error) {
        console.error(`FAILURE in test '${testFunction.name}':`, error.message);
        const screenshotPath = path.resolve(__dirname, `${testFunction.name}_failure.png`);
        await page.screenshot({ path: screenshotPath });
        console.log(`Screenshot saved to ${screenshotPath}`);
        throw error; // Re-throw to stop the main execution
    }
}

async function testAddTask(page) {
    console.log('\n--- Running Test: Add Task ---');
    const taskDescription = 'A new test task ' + Date.now(); // Unique description

    console.log('Clicking "Add Task"...');
    await page.click('#addTaskButton');

    console.log('Filling out the new task form...');
    await page.waitForSelector('#addTaskModal', { visible: true });
    await page.type('#taskDescription', taskDescription);
    await page.type('#taskPerson', 'Test User');
    await page.type('#taskDate', '2025-12-25');
    await page.click('#addTaskModal .btn-success');

    console.log('Verifying task was added with correct status...');
    await page.waitForFunction(
        desc => document.body.innerText.includes(desc),
        {},
        taskDescription
    );

    const taskWasAdded = await page.evaluate((desc) => {
        const allTasks = Array.from(document.querySelectorAll('.task-item'));
        const newTaskItem = allTasks.find(task => task.innerText.includes(desc));
        if (!newTaskItem) return false;

        const statusBadge = newTaskItem.querySelector('.badge');
        if (!statusBadge) return false;

        return statusBadge.innerText.trim() === 'To Do';
    }, taskDescription);

    if (taskWasAdded) {
        console.log('SUCCESS: Task added successfully with "To Do" status.');
        return true;
    } else {
        throw new Error('Task was not found or status was incorrect.');
    }
}

async function testStatusCycling(page) {
    console.log('\n--- Running Test: Status Cycling ---');
    const taskDescription = 'A task for status cycling ' + Date.now();

    // 1. Add a prerequisite task
    console.log('Adding a prerequisite task...');
    await page.click('#addTaskButton');
    await page.waitForSelector('#addTaskModal', { visible: true });
    await page.type('#taskDescription', taskDescription);
    await page.type('#taskPerson', 'Cycle Tester');
    await page.type('#taskDate', '2025-10-10');
    await page.click('#addTaskModal .btn-success');
    await page.waitForFunction(
        desc => document.body.innerText.includes(desc),
        {},
        taskDescription
    );
    console.log('Prerequisite task added.');

    // Get the ID of the newly created task
    const taskId = await page.evaluate((desc) => {
        const taskItem = Array.from(document.querySelectorAll('.task-item')).find(task => task.innerText.includes(desc));
        return taskItem ? taskItem.getAttribute('data-task-id') : null;
    }, taskDescription);

    if (!taskId) {
        throw new Error('Could not find the new task or its ID after adding it.');
    }
    console.log(`Prerequisite task added with ID: ${taskId}`);

    // Helper function to get badge info by task ID
    const getBadgeInfo = async () => {
        return page.evaluate((id) => {
            const taskItem = document.querySelector(`.task-item[data-task-id='${id}']`);
            if (!taskItem) return null;
            const badge = taskItem.querySelector('.badge');
            if (!badge) return null;
            const text = badge.textContent.trim();
            const charCodes = text.split('').map(char => char.charCodeAt(0));
            return { text: text, className: badge.className, charCodes: charCodes };
        }, taskId);
    };

    // Helper to click the badge by task ID
    const clickBadge = async () => {
        const selector = `.task-item[data-task-id='${taskId}'] .badge`;
        await page.waitForSelector(selector, { visible: true });
        await page.click(selector);
    };

    // 2. Verify initial state and cycle through statuses
    console.log('Verifying initial state: To Do');
    let badgeInfo = await getBadgeInfo();

    // --- Start Debug Logging ---
    if (badgeInfo) {
        console.log(`DEBUG: Badge text is: '${badgeInfo.text}'`);
        console.log(`DEBUG: Badge text length is: ${badgeInfo.text.length}`);
        console.log(`DEBUG: Badge char codes are: [${badgeInfo.charCodes.join(', ')}]`);
        const expected = 'To Do';
        const expectedCharCodes = expected.split('').map(c => c.charCodeAt(0));
        console.log(`DEBUG: Expected char codes are: [${expectedCharCodes.join(', ')}]`);
    }
    // --- End Debug Logging ---

    if (!badgeInfo || badgeInfo.text.trim() !== 'To Do' || !badgeInfo.className.includes('bg-primary')) {
        throw new Error(`Initial state incorrect. Expected 'To Do' with 'bg-primary'. Found: ${JSON.stringify(badgeInfo)}`);
    }
    console.log('Initial state is correct.');

    console.log(`Clicking badge to cycle to 'In Progress'...`);
    await clickBadge();
    await page.waitForFunction(id => {
        const badge = document.querySelector(`.task-item[data-task-id='${id}'] .badge`);
        return badge && badge.textContent.includes('In Progress') && badge.classList.contains('bg-warning');
    }, {}, taskId);
    badgeInfo = await getBadgeInfo();
    if (!badgeInfo || badgeInfo.text.trim() !== 'In Progress' || !badgeInfo.className.includes('bg-warning')) {
        throw new Error(`State after first click incorrect. Expected 'In Progress' with 'bg-warning'. Found: ${JSON.stringify(badgeInfo)}`);
    }
    console.log("'In Progress' state is correct.");

    console.log(`Clicking badge to cycle to 'Done'...`);
    await clickBadge();
    await page.waitForFunction(id => {
        const badge = document.querySelector(`.task-item[data-task-id='${id}'] .badge`);
        return badge && badge.textContent.includes('Done') && badge.classList.contains('bg-success');
    }, {}, taskId);
    badgeInfo = await getBadgeInfo();
    if (!badgeInfo || badgeInfo.text.trim() !== 'Done' || !badgeInfo.className.includes('bg-success')) {
        throw new Error(`State after second click incorrect. Expected 'Done' with 'bg-success'. Found: ${JSON.stringify(badgeInfo)}`);
    }
    console.log("'Done' state is correct.");

    console.log(`Clicking badge to cycle back to 'To Do'...`);
    await clickBadge();
    await page.waitForFunction(id => {
        const badge = document.querySelector(`.task-item[data-task-id='${id}'] .badge`);
        return badge && badge.textContent.includes('To Do') && badge.classList.contains('bg-primary');
    }, {}, taskId);
    badgeInfo = await getBadgeInfo();
    if (!badgeInfo || badgeInfo.text.trim() !== 'To Do' || !badgeInfo.className.includes('bg-primary')) {
        throw new Error(`State after third click incorrect. Expected 'To Do' with 'bg-primary'. Found: ${JSON.stringify(badgeInfo)}`);
    }
    console.log("'To Do' state is correct after cycling back.");

    console.log('SUCCESS: Status cycling test passed.');
    return true;
}

async function testDeleteTask(page) {
    console.log('\n--- Running Test: Delete Task ---');
    const taskToDeleteDesc = 'Test Task: To Be Deleted ' + Date.now();

    // 1. Add a prerequisite task to delete
    console.log('Adding prerequisite task...');
    await page.click('#addTaskButton');
    await page.waitForSelector('#addTaskModal', { visible: true });
    await page.type('#taskDescription', taskToDeleteDesc);
    await page.type('#taskPerson', 'Delete Runner');
    await page.type('#taskDate', '2025-01-01');
    await page.click('#addTaskModal .btn-success');
    await page.waitForSelector('#addTaskModal', { hidden: true });
    await page.waitForFunction((desc) => document.body.innerText.includes(desc), {}, taskToDeleteDesc);
    console.log('Prerequisite task added.');

    // 2. Find the task to delete and get its ID
    console.log('Finding task to delete...');
    const taskId = await page.evaluate((desc) => {
        const taskItem = Array.from(document.querySelectorAll('.task-item')).find(task => task.innerText.includes(desc));
        return taskItem ? taskItem.getAttribute('data-task-id') : null;
    }, taskToDeleteDesc);

    if (!taskId) throw new Error('Could not find the prerequisite task to delete.');

    // 3. Click the dropdown toggle and then the delete link
    console.log('Clicking delete to open confirmation modal...');
    const dropdownSelector = `.task-item[data-task-id='${taskId}'] .dropdown-toggle`;
    await page.waitForSelector(dropdownSelector, { visible: true });
    await page.click(dropdownSelector);
    
    const deleteLinkSelector = `.task-item[data-task-id='${taskId}'] .dropdown-item.text-danger`;
    await page.waitForSelector(deleteLinkSelector, { visible: true });
    await page.click(deleteLinkSelector);

    // 4. Confirm the deletion in the modal
    console.log('Confirming deletion...');
    await page.waitForSelector('#deleteConfirmationModal', { visible: true });
    await page.click('#confirmDeleteButton');
    await page.waitForSelector('#deleteConfirmationModal', { hidden: true });

    // 5. Verify the task is gone
    console.log('Verifying task has been removed...');
    await page.waitForFunction((desc) => !document.body.innerText.includes(desc), {}, taskToDeleteDesc);
    const taskIsGone = await page.evaluate((desc) => {
        const taskListContainer = document.getElementById('taskListContainer');
        return !taskListContainer || !taskListContainer.innerText.includes(desc);
    }, taskToDeleteDesc);

    if (!taskIsGone) {
        throw new Error('Task was still found in the list after deleting.');
    }
    console.log('SUCCESS: Task deleted successfully.');
}

async function testStatusCycling(page) {
    console.log('\n--- Running Test: Status Cycling ---');
    const taskDescription = 'A cycling test task ' + Date.now();

    console.log('Adding a task for the cycling test...');
    await page.click('#addTaskButton');
    await page.waitForSelector('#addTaskModal', { visible: true });
    await page.type('#taskDescription', taskDescription);
    await page.type('#taskPerson', 'Cycle User');
    await page.type('#taskDate', '2025-01-01');
    await page.click('#addTaskModal .btn-success');
    await page.waitForFunction(
        desc => document.body.innerText.includes(desc),
        {},
        taskDescription
    );
    console.log('Task added.');

    const getTaskId = async (desc) => {
        return await page.evaluate((d) => {
            const taskItem = Array.from(document.querySelectorAll('.task-item')).find(el => el.innerText.includes(d));
            return taskItem ? taskItem.dataset.taskId : null;
        }, desc);
    };
    
    const taskId = await getTaskId(taskDescription);
    if (!taskId) throw new Error('Could not find the newly created task for cycling.');
    const badgeSelector = `[data-task-id="${taskId}"] .badge`;

    console.log('Verifying initial status is "To Do"...');
    await page.waitForSelector(badgeSelector, { visible: true });
    let status = await page.$eval(badgeSelector, el => el.innerText.trim());
    if (status !== 'To Do') throw new Error(`Expected "To Do", got "${status}"`);
    console.log('Status OK.');

    console.log('Clicking to "In Progress"...');
    await page.click(badgeSelector);
    await page.waitForFunction(s => document.querySelector(s).innerText.trim() === 'In Progress', {}, badgeSelector);
    status = await page.$eval(badgeSelector, el => el.innerText.trim());
    if (status !== 'In Progress') throw new Error(`Expected "In Progress", got "${status}"`);
    console.log('Status OK.');

    console.log('Clicking to "Done"...');
    await page.click(badgeSelector);
    await page.waitForFunction(s => document.querySelector(s).innerText.trim() === 'Done', {}, badgeSelector);
    status = await page.$eval(badgeSelector, el => el.innerText.trim());
    if (status !== 'Done') throw new Error(`Expected "Done", got "${status}"`);
    console.log('Status OK.');

    console.log('Clicking back to "To Do"...');
    await page.click(badgeSelector);
    await page.waitForFunction(s => document.querySelector(s).innerText.trim() === 'To Do', {}, badgeSelector);
    status = await page.$eval(badgeSelector, el => el.innerText.trim());
    if (status !== 'To Do') throw new Error(`Expected "To Do", got "${status}"`);
    console.log('Status OK.');

    console.log('Cleaning up by deleting the test task...');
    const deleteButtonSelector = `[data-task-id="${taskId}"] .dropdown-toggle`;
    const deleteLinkSelector = `[data-task-id="${taskId}"] .dropdown-item.text-danger`;
    await page.click(deleteButtonSelector);
    await page.waitForSelector(`[data-task-id="${taskId}"] .dropdown-menu.show`, { visible: true });
    await page.click(deleteLinkSelector);
    await page.waitForSelector('#deleteConfirmationModal', { visible: true });
    await page.click('#confirmDeleteButton');
    await page.waitForFunction(desc => !document.body.innerText.includes(desc), {}, taskDescription);
    console.log('Cleanup complete.');

    console.log('SUCCESS: Status cycling test passed.');
}

(async () => {
    let browser;
    let server;
    try {
        console.log('Starting server...');
        server = spawn('npx', ['http-server', path.resolve(__dirname, '..'), '-p', '8081', '-c-1']);

        await new Promise((resolve, reject) => {
            const timer = setTimeout(() => reject(new Error('Server startup timed out')), 10000); // 10-second timeout
            server.stdout.on('data', (data) => {
                if (data.toString().includes('Available on:')) {
                    console.log('Server is ready.');
                    clearTimeout(timer);
                    resolve();
                }
            });
            server.stderr.on('data', (data) => {
                console.error(`Server stderr: ${data}`);
                clearTimeout(timer);
                reject(new Error(`Server failed to start: ${data}`));
            });
        });

        console.log('Launching browser...');
        browser = await puppeteer.launch({ headless: true, args: ['--no-sandbox', '--disable-setuid-sandbox'] });
        const page = await browser.newPage();

        page.on('console', msg => {
            for (let i = 0; i < msg.args().length; ++i) {
                console.log(`[Browser Console] ${msg.type().toUpperCase()}: ${msg.text()}`);
            }
        });

        console.log('Navigating to http://localhost:8081/TaskListPage.html...');
        await page.goto('http://localhost:8081/TaskListPage.html', { waitUntil: 'networkidle2' });

        await runTest(testAddTask, page);
        await runTest(testStatusCycling, page);
        await runTest(testDeleteTask, page);

        console.log('\nTest suite passed.');
    } catch (error) {
        console.error(`\n${error.message}`);
        console.log('Test suite failed.');
        process.exitCode = 1;
    } finally {
        if (browser) {
            await browser.close();
        }
        if (server) {
            console.log('Stopping server...');
            server.kill();
        }
    }
})();